---
title: "Exploración de la heterogeneidad"
author:
  - name: Tamara Ricardo
    orcid: 0000-0002-0921-2611
bibliography: references.bib
---

```{r}
#| echo: false 
source("../setup.R")
```

## Análisis de moderadores

El análisis de moderadores permite explorar fuentes de heterogeneidad entre los estudios incluidos en un meta-análisis. Se puede realizar mediante la inclusión de una variable independiente categórica (*análisis de subgrupos*) o numérica (*metarregresión*).

Este procedimiento contribuye a evaluar hipótesis sobre variaciones en la magnitud del efecto entre estudios y a interpretar diferencias observadas en los resultados. Sin embargo, para evitar sesgos de selección, las variables utilizadas como moderadores deben definirse de antemano, durante la extracción de datos relevantes para la revisión sistemática.

El análisis de moderadores consta de dos etapas:

-   Estimación del efecto **dentro de cada subgrupo.**

-   Prueba estadística para evaluar diferencias **entre subgrupos**.

### Análisis de sugbgrupos

Para evaluar el efecto de una variable categórica, se puede utilizar el argumento `subgroup` al ajustar un modelo de meta-análisis. A continuación, realizaremos un análisis de subgrupos sobre el [modelo de prevalencia](tipos_estimador.qmd#prevalencia) ajustado previamente, considerando el país (`country`) como moderador.

Comenzaremos cargando los paquetes necesarios:

```{r}
# Carga de paquetes
library(meta)       # Modelos de meta-análisis
library(scico)      # Paletas de colores accesibles
library(janitor)    # Tablas de frecuencia
library(tidyverse)  # Manejo de datos

# Paleta colorblind-friendly
pal <- scico(n = 4, palette = "buda")
```

Cargamos los datos y exploramos su estructura:

```{r}
# Cargar datos
datos_prev <- dat.crisafulli2020

# Inspeccionar estructura de los datos
glimpse(datos_prev)
```

Usaremos la función `tabyl()` del paquete `janitor` [@janitor] para generar una tabla de frecuencias de los niveles de la variable `country`:

```{r}
tabyl(datos_prev, country) |>   # Genera tabla de frecuencia
  arrange(-n) |>                # Ordena por frecuencia
  adorn_pct_formatting()        # Proporciones a porcentajes
```

Dado que la mayoría de los estudios provienen de Italia y la frecuencia en otros países es baja, creamos una variable dicotómica `pais_cat`:

```{r}
datos_prev <- datos_prev |> 
  mutate(pais_cat = if_else(
    country  == "IT", # Condición
    "Italia",         # Valor si la condición se cumple
    "Otro/s" )        # Valor si la condición no se cumple
  )
```

Ajustamos el modelo de meta-análisis para proporciones, incorporando la variable `pais_cat` como moderador:

```{r}
# Ajuste modelo
mod_sg <- metaprop(
  event = cases,          # Casos observados
  n = total,              # Tamaño de la muestra
  studlab = study,        # Identificador del estudio
  data = datos_prev,      # Conjunto de datos
  sm = "PLOGIT",          # Transformación logit
  common = FALSE,         # Omitir modelo de efectos fijos
  random = TRUE,          # Modelo de efectos aleatorios
  pscale = 100000,        # Escala a casos/100 000 habitantes
  subgroup = pais_cat     # Moderador categórico
)

# Resumen del modelo ajustado
mod_sg
```

La salida del modelo incluye dos secciones adicionales:

-   `Results for subgroups (random effects model)`: muestra los resultados para cada categoría del moderador, incluyendo:

    -   Identificador de las categorías del moderador.

    -   `k`: número de estudios en la categoría/subgrupo.

    -   `events`: prevalencia en la categoría/subgrupo.

    -   `95%-CI`: intervalo de confianza al 95% para la prevalencia en la categoría/subgrupo.

    -   `tau^2`: varianza dentro de la categoría/subgrupo.

    -   `tau`: desvío estándar en la categoría/subgrupo.

    -   `Q`: estadístico Q de Cochran para la categoría/subgrupo.

    -   `I^2`: porcentaje de heterogeneidad observado en la categoría/subgrupo.

-   `Test for subgroup differences (random effects model)`: prueba de hipótesis para detectar diferencias significativas entre subgrupos.

En este ejemplo, observamos una prevalencia significativamente mayor en Italia en comparación con otros países $(p = 0,013)$.

Podemos visualizar los resultados del análisis de moderadores incorporando los siguiente argumentos a la función `forest()`:

-   `layout = "subgroup"`: muestra los estimadores de efecto para cada subgrupo y el estimador global, omitiendo los resultados de los estudios individuales.

-   `sort.subgroup`: ordena alfabeticamente las categorías de la variable moderadora.

-   `calcwidth.subgroup`: ajusta el ancho del forest plot para que se muestren correctamente las etiquetas de las categorías/subgrupos.

-   `calcwidth.tests`: ajusta el ancho del forest plot para que se muestren correctamente las etiquetas del test de hipótesis de diferencias en las categorías/subgrupos.

-   `print.subgroup.name`: muestra la etiqueta de la variable moderadora delante de cada categoría (`TRUE`, por defecto) o lo oculta (`FALSE`).

-   `label.test.subgroup.common`: etiqueta para los resultados del test para diferencias entre subgrupos en el modelo de efectos fijos.

-   `label.test.subgroup.random`: etiqueta para los resultados del test para diferencias entre subgrupos en el modelo de efectos aleatorios.

En nuestro ejemplo:

```{r}
#| fig-height: 4
#| fig-width: 9
forest(
  mod_sg,
  layout = "subgroup",
  sort.subgroup = TRUE,
  calcwidth.subgroup = TRUE,
  calcwidth.tests = TRUE,
  print.subgroup.name = FALSE,
  smlab = "Prevalencia \n (por 100 000 hab.)",
  rightlabs = c("Eventos", "95% IC"),
  hetlab = "Heterogeneidad: ",
  text.random = "Modelo de efectos aleatorios", 
  label.test.subgroup.random = "Diferencias entre subgrupos"
)
```

A diferencia de modelos sin moderadores, `col.diamond` modifica el color del estimador global y de los estimadores para cada subgrupo. En cambio, `col.square` no tiene efecto sobre los colores del forest plot.

### Metarregresión

Para evaluar el efecto de una variable continua, como el año de publicación (`pubyear`), primero ajustamos el modelo de meta-análisis:

```{r}
# Ajuste modelo
mod_prev <- metaprop(
  event = cases,          # Casos observados
  n = total,              # Tamaño de la muestra
  studlab = study,        # Identificador del estudio
  data = datos_prev,      # Conjunto de datos
  sm = "PLOGIT",          # Transformación logit
  common = FALSE,         # Omitir modelo de efectos fijos
  random = TRUE,          # Modelo de efectos aleatorios
  pscale = 100000,        # Escala a casos/100 000 habitantes
 )
```

Al modelo anterior le aplicamos la función `metareg()`, incluyendo `pubyear` como moderador en el argumento `formula`:

```{r}
# Ajustar modelo de metarregresión
mod_year <- metareg(mod_prev,
                    formula = ~ pubyear)

# Resumen del modelo ajustado
summary(mod_year)
```

Los resultados muestran un efecto estadísticamente significativo del año de publicación sobre la prevalencia del evento $(p = 0,008)$.

Los resultados de la metarregresión se visualizan usando *bubble plots.* Estos gráficos representan en el eje $X$ el valor del moderador continuo y en el eje $Y$ el efecto estimado para cada estudio. Cada burbuja representa un estudio individual, y su tamaño es proporcional al peso del estudio (generalmente inversamente proporcional a la varianza). Además, el gráfico incluye una línea de regresión con su intervalo de confianza del 95%, permitiendo visualizar la tendencia general.

La función `bubble()` genera este gráfico de forma rápida:

```{r}
bubble(
  mod_year,
  cex = "common",        # Escala de los símbolos
  col.line = pal[2]      # Color de la línea de regresión
)
```

Para ajustar el tamaño de las burbujas según el peso de cada estudio, se puede modificar el argumento `cex` utilizando la función `rescale()` del paquete `plotrix`:

```{r}
bubble(
  mod_year,
  cex = plotrix::rescale(
    x = 1 / mod_year$vi,
    newrange = c(0.5, 3)),  # Ajusta la escala de los símbolos
    col.line = pal[2]
)
```

### Visualización avanzada con paquete orchaRd

Este contenido es opcional y está dirigido a quienes tengan conocimientos más avanzados de R y deseen generar visualizaciones más atractivas y listas para la presentación en informes o artículos científicos.

El paquete orchaRd [@orchaRd] permite crear visualizaciones con mayores opciones de personalización y compatibles con `ggplot2`. Sin embargo, dado que `orchaRd` no permite utilizar modelos ajustados por el paquete `meta`, es necesario reajustar el modelo utilizando `metafor.`

Cargamos los paquetes requeridos:

```{r}
# Carga paquetes
library(orchaRd)
library(metafor)
```

Calculamos los estimadores de efecto individuales utilizando la función `escalc()`:

```{r}
dat_forest <- escalc(
  measure = "PLO",     # estimador de efecto
  xi = cases,          # número de casos
  ni = total,          # tamaño muestral
  data = datos_prev    # conjunto de datos
  )  
```

Ajustamos el modelo de meta-análisis con moderadores utilizando `rma.mv()`:

```{r}
mod_forest <- rma.mv(
  yi = yi,                             # estimador de efecto
  V = vi,                              # error estándar
  mods = ~ factor(pais_cat) + pubyear, # moderadores
  random = ~ 1|study,                  # modelo de efectos aleatorios
  data = dat_forest                    # conjunto de datos
)
```

Generamos el forest plot con la función `orchard_plot()`, definiendo los siguientes argumentos:

-   `group`: identificador de estudio.

-   `mod`: nombre del moderador (1 para estimador de efecto global).

-   `xlab`: nombre del estimador de efecto.

-   `transf`: mostrar los datos en escala original (opcional).

```{r}
# Forest plot por subgrupos
orchard_plot(
  mod_forest, 
  group = "study",
  mod = "pais_cat",
  xlab = "prevalencia",
  transfm = "invlogit"
  ) +
  # Paleta personalizada
  scale_color_manual(values = pal) +  # color de borde
  scale_fill_manual(values = pal)     # color de relleno
```

Con el argumento `scale_fill_scico_d()` podemos usar cualquiera de las paletas *colorblind-friendly* incluidas en `scico`:

```{r}
# Forest plot por subgrupos
orchard_plot(
  mod_forest, 
  group = "study",
  mod = "pais_cat",
  xlab = "prevalencia",
  transfm = "invlogit"
  ) +
  # Paleta colorblind-friendly
  scale_color_scico_d(palette = "hawaii") + # color de borde
  scale_fill_scico_d(palette = "hawaii")    # color de relleno
```

Generamos el bubble plot para el moderador continuo (`pubyear`):

```{r}
bubble_plot(
  mod_forest,           # modelo ajustado con metafor
  transfm = "invlogit", # muestra resultados como proporciones
  mod = "pubyear",      # moderador continuo
  group = "study",      # identificador de estudio
  est.col = pal[2],     # color de la línea de regresión
  ci.col = pal[1],      # color de las líneas del 95% IC
  ) 
```

Si quisiera generar un bubble plot para cada nivel de `pais_cat`, puedo usar el argumento `by`:

```{r}
bubble_plot(
  mod_forest,           # modelo ajustado con metafor
  transfm = "invlogit", # muestra resultados como proporciones
  mod = "pubyear",      # moderador continuo
  group = "study",      # identificador de estudio
  est.col = pal[2],     # color de la línea de regresión
  ci.col = pal[1],      # color de las líneas del 95% IC
  by = "pais_cat"
  ) +
  
  # Paleta colorblind-friendly
  scale_color_scico_d(palette = "glasgow") + # color de borde
  scale_fill_scico_d(palette = "glasgow")    # color de relleno
```

```{r}
#| echo: false
pacman::p_unload(metafor, 
                 orchaRd)
```

## Sesgo de publicación y análisis de sensibilidad

El sesgo de publicación (*publication bias*) se refiere a la tendencia de publicar con mayor frecuencia estudios con resultados positivos, estadísticamente significativos o con grandes tamaños del efecto. Esto puede distorsionar la síntesis de la evidencia en un meta-análisis, produciendo una sobreestimación del efecto global. Por ello, es esencial evaluar y ajustar el sesgo de publicación para garantizar que los resultados sean lo más precisos y representativos posible.

### **Funnel plot**

El funnel plot o gráfico de embudo representa en el eje $Y$ el tamaño muestral o la precisión de los estudios, y en el eje $X$ el estimador de efecto para cada estudio. En ausencia de sesgo de publicación, se espera una distribución simétrica que forme un patrón similar a un embudo; de lo contrario, se observa asimetría.

Para generar un funnel plot, se utiliza la función `funnel()`:

```{r}
funnel(mod_prev)
```

### **Test de Egger**

El test de Egger evalúa la simetría del funnel plot mediante una regresión lineal entre el estimador de efecto y su error estándar. Un *p*-valor menor a 0,05 sugiere la presencia de sesgo de publicación.

Este test se implementa con la función `metabias()`:

```{r}
metabias(
  mod_prev,               # modelo de meta-análisis
  method.bias = "Egger"   # aplica test de Egger (opción por defecto)
  )
```

### **Test de Begg**

El test de Begg utiliza la correlación de rangos para evaluar la relación entre el tamaño del efecto y el error estándar. Un *p*-valor menor que 0,05 indica la presencia de sesgo de publicación.

Se implementa añadiendo el argumento `method.bias = "Begg"` a la función `metabias()`:

```{r}
metabias(
  mod_prev,             # modelo de meta-análisis
  method.bias = "Begg"  # aplica test de Begg
  )
```

### ***Trim-and-fill***

El método *trim-and-fill* estima el número de estudios faltantes debido al sesgo de publicación y ajusta la media global en consecuencia, incorporando estudios hipotéticos. Esto ayuda a corregir la estimación del efecto global.

Se utiliza la función `trimfill()`:

```{r}
trimfill(mod_prev)
```

Generalmente, se recomienda utilizar dos o más métodos para evaluar el sesgo de publicación y obtener una visión más completa de su impacto en el meta-análisis. En el ejemplo anterior, no hubiera sido necesario realizar el *trim-and-fill* ya que el funnel plot tiene una forma bastante simétrica y el *p*-valor de los test de Egger y Begg fue menor a 0,05.

### Análisis de sensibilidad

El análisis de sensibilidad se utiliza para evaluar la robustez de los resultados del meta-análisis. Una estrategia común es reajustar el modelo excluyendo estudios con menor tamaño muestral o de menor calidad, y comparar el estimador de efecto y su 95% IC con el modelo original. Otra opción es realizar un análisis *leave-one-out*, en el que se remueve un estudio a la vez y se observa la variación del efecto global.

La función `metainf()` permite realizar el análisis de influencia (*leave-one-out*):

```{r}
#| eval: false
metainf(
  mod_prev,          # modelo de meta-análisis
  pooled = "random"  # modelo de efectos aleatorios
  )
```

Este análisis ayuda a determinar si algún estudio en particular influye de forma excesiva en los resultados del meta-análisis. Al igual que en los modelos anteriores, los resultados pueden visualizarse usando forest plots.

::: {.callout-note appearance="simple"}
Hasta aquí hemos cubierto los aspectos básicos para evaluar fuentes de heterogeneidad en modelos de meta-análisis. Quienes tengan interés en profundizar en las medidas de heterogeneidad y su aplicación, recomendamos consultar el artículo de [@bown2010] y los capítulos [7](https://bookdown.org/MathiasHarrer/Doing_Meta_Analysis_in_R/subgroup.html), [8](https://bookdown.org/MathiasHarrer/Doing_Meta_Analysis_in_R/metareg.html) y [9](https://bookdown.org/MathiasHarrer/Doing_Meta_Analysis_in_R/pub-bias.html) de @Harrer2021.
:::
